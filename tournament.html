<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tournament</title>

<link rel="stylesheet" href="style.css">
</head>

<body>

<div class="container">

<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px;">
  <button onclick="location.href='index.html'" style="background: var(--border); padding: 8px 12px; font-size: 0.9rem;">← Back</button>
  <h1 id="title" style="margin: 0; flex-grow: 1;"></h1>
</div>

<div id="fixtures" class="section active">
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
    <h2>Fixtures</h2>
    <select id="roundFilter" onchange="render()" style="padding: 5px; border-radius: 5px; border: 1px solid var(--border);"></select>
</div>
<button class="add-match-btn" onclick="openAdd()">+ Add Match</button>
<div id="fixturesList"></div>
</div>

<div id="scores" class="section">
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
    <h2>Scores</h2>
</div>
<div id="scoresList"></div>
</div>

<div id="table" class="section">
<h2>Standings</h2>
<table>
<thead>
<tr>
<th>Team</th><th>P</th><th>W</th><th>D</th><th>L</th>
<th>GF</th><th>GA</th><th>GD</th><th>Pts</th>
</tr>
</thead>
<tbody id="standings"></tbody>
</table>
</div>

</div>

<nav class="navbar">
<div class="nav-item active" onclick="show('fixtures',this)">Fixtures</div>
<div class="nav-item" onclick="show('scores',this)">Scores</div>
<div class="nav-item" onclick="show('table',this)">Table</div>
</nav>

<!-- ADD MATCH -->
<div id="addModal" class="modal">
<div class="modal-content">
<h3>Add Match</h3>
<input id="roundInput" type="number" value="1">
<select id="home"></select>
<select id="away"></select>
<button onclick="closeAll()">Cancel</button>
<button onclick="saveMatch()">Save</button>
</div>
</div>

<!-- RESULT -->
<div id="resultModal" class="modal">
<div class="modal-content">
<h3>Enter Result</h3>
<input id="sh" type="number" placeholder="Home goals">
<input id="sa" type="number" placeholder="Away goals">
<button onclick="closeAll()">Cancel</button>
<button onclick="saveResult()">Confirm</button>
</div>
</div>

<script type="module">

import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
import { getFirestore,doc,onSnapshot,updateDoc,arrayUnion } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";

const firebaseConfig={
apiKey:"AIzaSyBYFoGEfyxSc_8h_GryQ4HXk9UDZf6I9Vc",
authDomain:"football-manager-a8c11.firebaseapp.com",
projectId:"football-manager-a8c11",
storageBucket:"football-manager-a8c11.appspot.com",
messagingSenderId:"78452499051",
appId:"1:78452499051:web:5f26427727d1d17024c72e"
};

const app=initializeApp(firebaseConfig);
const db=getFirestore(app);

const id=new URLSearchParams(location.search).get("id");
const ref=doc(db,"tournaments",id);

let T=null;
let currentIndex=null;

onSnapshot(ref,s=>{
if(!s.exists())return;
T=s.data();
if(!T.matches) T.matches = [];
updateRoundFilter();
render();
});

function updateRoundFilter() {
    const rounds = [...new Set(T.matches.map(m => m.round))].sort((a,b) => a-b);
    const currentFilter = roundFilter.value;
    roundFilter.innerHTML = '<option value="all">All Rounds</option>';
    rounds.forEach(r => {
        roundFilter.innerHTML += `<option value="${r}">Round ${r}</option>`;
    });
    if (currentFilter) roundFilter.value = currentFilter;
}

function render(){

title.innerText=T.name;

const selectedRound = roundFilter.value;

home.innerHTML="";
away.innerHTML="";
T.teams.forEach(t=>{
home.innerHTML+=`<option>${t}</option>`;
away.innerHTML+=`<option>${t}</option>`;
});

fixturesList.innerHTML="";
scoresList.innerHTML="";

const stats={};
T.teams.forEach(t=>{
stats[t]={p:0,w:0,d:0,l:0,gf:0,ga:0};
});

// Group matches by round
const matchesByRound = {};
T.matches.forEach((m, i) => {
    if (selectedRound !== "all" && m.round != selectedRound) return;
    if (!matchesByRound[m.round]) matchesByRound[m.round] = [];
    matchesByRound[m.round].push({ ...m, originalIndex: i });
});

const sortedRounds = Object.keys(matchesByRound).sort((a,b) => a-b);

sortedRounds.forEach(r => {
    const roundDiv = document.createElement('div');
    roundDiv.className = 'round-container';
    roundDiv.innerHTML = `<h3 class="round-title">Round ${r}</h3>`;
    
    const roundFixtures = document.createElement('div');
    const roundScores = document.createElement('div');

    matchesByRound[r].forEach(m => {
        const i = m.originalIndex;
        if(m.scoreHome!=null){
            roundScores.innerHTML+=`
            <div class="match-card">
            <span>${m.home} ${m.scoreHome} - ${m.scoreAway} ${m.away}</span>
            <div style="display:flex; gap:5px;">
                <button class="edit-btn" onclick="openResult(${i})">✎</button>
                <button class="del" onclick="delScore(${i})">X</button>
            </div>
            </div>`;

            let h=stats[m.home], a=stats[m.away];
            h.p++;a.p++;
            h.gf+=m.scoreHome;h.ga+=m.scoreAway;
            a.gf+=m.scoreAway;a.ga+=m.scoreHome;

            if(m.scoreHome>m.scoreAway){h.w++;a.l++;}
            else if(m.scoreHome<m.scoreAway){a.w++;h.l++;}
            else{h.d++;a.d++;}
        }else{
            roundFixtures.innerHTML+=`
            <div class="match-card">
            <span onclick="openResult(${i})">${m.home} vs ${m.away}</span>
            <button class="del" onclick="del(${i})">X</button>
            </div>`;
        }
    });

    if (roundFixtures.innerHTML) {
        const fWrapper = document.createElement('div');
        fWrapper.className = 'round-section';
        fWrapper.innerHTML = `<h3 class="round-title">Round ${r}</h3>`;
        fWrapper.appendChild(roundFixtures);
        fixturesList.appendChild(fWrapper);
    }
    if (roundScores.innerHTML) {
        const sWrapper = document.createElement('div');
        sWrapper.className = 'round-section';
        sWrapper.innerHTML = `<h3 class="round-title">Round ${r}</h3>`;
        sWrapper.appendChild(roundScores);
        scoresList.appendChild(sWrapper);
    }
});

const arr=Object.entries(stats).map(([k,v])=>{
v.team=k;
v.gd=v.gf-v.ga;
v.pts=v.w*3+v.d;
return v;
});

arr.sort((a,b)=>b.pts-a.pts||b.gd-a.gd||b.gf-a.gf);

standings.innerHTML="";
arr.forEach(t=>{
standings.innerHTML+=`
<tr>
<td>${t.team}</td><td>${t.p}</td><td>${t.w}</td><td>${t.d}</td><td>${t.l}</td>
<td>${t.gf}</td><td>${t.ga}</td><td>${t.gd}</td><td>${t.pts}</td>
</tr>`;
});
}

window.show=(id,e)=>{
document.querySelectorAll(".section").forEach(s=>s.classList.remove("active"));
document.getElementById(id).classList.add("active");
document.querySelectorAll(".nav-item").forEach(n=>n.classList.remove("active"));
e.classList.add("active");
};

window.openAdd=()=> {
    // Determine next round and home/away swap
    const lastMatch = T.matches[T.matches.length - 1];
    let nextRound = lastMatch ? lastMatch.round : 1;
    
    // Check if current round is "full" (all teams played once)
    const currentRoundMatches = T.matches.filter(m => m.round === nextRound);
    if (currentRoundMatches.length >= T.teams.length / 2) {
        nextRound++;
    }
    
    roundInput.value = nextRound;
    
    // Auto-select teams that haven't played in this round yet
    const playedTeams = new Set();
    currentRoundMatches.forEach(m => {
        playedTeams.add(m.home);
        playedTeams.add(m.away);
    });
    
    const availableTeams = T.teams.filter(t => !playedTeams.has(t));
    if (availableTeams.length >= 2) {
        home.value = availableTeams[0];
        away.value = availableTeams[1];
        
        // Handle home/away swap for return leg (round 20+)
        if (nextRound >= 20) {
            const previousMatch = T.matches.find(m => 
                (m.home === availableTeams[0] && m.away === availableTeams[1]) ||
                (m.home === availableTeams[1] && m.away === availableTeams[0])
            );
            if (previousMatch && previousMatch.home === availableTeams[0]) {
                home.value = availableTeams[1];
                away.value = availableTeams[0];
            }
        }
    }

    addModal.style.display="block";
}

window.closeAll=()=>{addModal.style.display=resultModal.style.display="none"}

window.saveMatch = async () => {
    if (home.value == away.value) {
        alert("Same team!");
        return;
    }

    const h = home.value;
    const a = away.value;
    const r = +roundInput.value;

    // Find any previous meeting between these two teams
    const previous = T.matches.find(m =>
        (m.home === h && m.away === a) ||
        (m.home === a && m.away === h)
    );

    // First leg (round < 20)
    if (r < 20) {
        if (previous) {
            alert("These teams have already played. Replay only allowed in second leg.");
            return;
        }
    }

    // Second leg (round >= 20)
    if (r >= 20) {
        if (!previous) {
            alert("Second leg not allowed. These teams never played in first leg.");
            return;
        }

        // Must be reversed
        if (previous.home === h && previous.away === a) {
            alert("Second leg must swap home and away.");
            return;
        }

        // Prevent third meeting
        const alreadySecondLeg = T.matches.some(m =>
            m.round >= 20 &&
            ((m.home === h && m.away === a) ||
             (m.home === a && m.away === h))
        );

        if (alreadySecondLeg) {
            alert("These teams already played both legs.");
            return;
        }
    }

    await updateDoc(ref, {
        matches: arrayUnion({
            round: r,
            home: h,
            away: a,
            scoreHome: null,
            scoreAway: null
        })
    });

    closeAll();
};

window.del=async(i)=>{
if(!confirm("Delete match?")) return;
T.matches.splice(i,1);
await updateDoc(ref,{matches:T.matches});
};

window.delScore=async(i)=>{
if(!confirm("Delete result and move back to fixtures?")) return;
T.matches[i].scoreHome = null;
T.matches[i].scoreAway = null;
await updateDoc(ref,{matches:T.matches});
};

window.openResult=i=>{
currentIndex=i;
sh.value = T.matches[i].scoreHome !== null ? T.matches[i].scoreHome : "";
sa.value = T.matches[i].scoreAway !== null ? T.matches[i].scoreAway : "";
resultModal.style.display="block";
};

window.saveResult=async()=>{
T.matches[currentIndex].scoreHome=+sh.value;
T.matches[currentIndex].scoreAway=+sa.value;
await updateDoc(ref,{matches:T.matches});
closeAll();
};

</script>
</body>
  </html>
  



